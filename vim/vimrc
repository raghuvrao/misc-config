scriptencoding utf-8

" ~/.vimrc ~/.vim/vimrc
" Author: Raghu V. Rao <raghu.v.rao@gmail.com>

set nobackup

set noundofile

set nomodeline
set modelines=0

let mapleader = '\'
let maplocalleader = '_'

set backspace=indent,eol,start

let &softtabstop=&tabstop

set ignorecase
set smartcase

set nowrap
nnoremap <Leader>w :set invwrap<CR>

set sidescroll=1

set nowildmenu
set wildmode=longest,list,full

" Set ruler even though I have line and column numbers in my statusline (see
" further below).  Infrequently and temporarily, I remove the statusline from
" view.  I want line- and column-number information to be displayed even in
" these situations.
set ruler

set showcmd

set foldmethod=indent
set foldlevel=100

set incsearch

nnoremap <Leader>h :nohlsearch<CR>

set list
set listchars=extends:#,precedes:#,nbsp:%
if has('multi_byte') && &encoding == 'utf-8'
  set listchars+=tab:→·,trail:¬
else
  set listchars+=tab:>\ ,trail:_
endif

set laststatus=2
set statusline=%(\ %f%)%(\ %q%)%(\ %M%R%H%W%)%(\ %y%)%(\ %l,%c%V\ %)

set autochdir

set report=0

" I do not want mouse support in Vim, whereas I like to have mouse support in
" GVim.  My system-wide vimrc enables mouse support in Vim, so disable it
" here.  Enable mouse support in GVim in the gvimrc file, which Vim does not
" read.
set mouse=

set nofixendofline

" Setting autoindent is typically unnecessary because filetype-specific
" indentation plugins take care of indentation sufficiently well.  However,
" with `n' included in formatoptions and with autoindent set, formatting
" numbered/bulleted lists (even in program comments) with the `gq' operator
" becomes so much easier.  Also, setting autoindent does not appear to be
" interfering with indentation done by filetype-specific indentation plugins.
" So, enable autoindent.
set autoindent

set conceallevel=0 concealcursor=

" ftplugins shall add to / remove from the following formatoptions.
set formatoptions=1jlmnq

filetype plugin indent on

runtime ftplugin/man.vim

augroup no_list
  autocmd!
  autocmd FileType help setlocal nolist
  autocmd FileType man setlocal nolist
augroup END

augroup no_automatic_insert_comment_leader
  autocmd!
  autocmd FileType * setlocal formatoptions-=o formatoptions-=r
augroup END

augroup no_automatic_hard_wrap
  autocmd!
  autocmd FileType * setlocal formatoptions-=c formatoptions-=t
augroup END

" Some ftplugins define textwidth, and others do not.  For those filetypes
" whose ftplugins do not define textwidth, set textwidth to 79.  I am making
" certain that textwidth is never zero for any filetype mostly to affect the
" behaviour of the gq operator.  When textwidth is 0, gq formats text to 79
" columns or the number of columns in the Vim window, whichever is smaller.
" Instead, I want gq to format to within 79 columns regardless of the Vim
" window size, unless the filetype's ftplugin says otherwise.  If the buffer
" does not have a filetype, do nothing about textwidth.  See :help gq.
augroup nonzero_textwidth_if_filetype_set
  autocmd!
  autocmd FileType * if &textwidth == 0 | setlocal textwidth=79 | endif
augroup END

augroup make_K_more_useful
  autocmd!
  " The following autocommand is redundant in Vim>=8.1.675 because
  " $VIMRUNTIME/ftplugin/help.vim sets keywordprg to :help in these versions.
  " TODO: remove this autocommand after upgrading.
  autocmd FileType help setlocal keywordprg=:help
  autocmd FileType man setlocal keywordprg=:Man
  " The following autocommand is redundant in Vim>=8.0.1290 because
  " $VIMRUNTIME/ftplugin/vim.vim sets keywordprg to :help in these versions.
  " TODO: remove this autocommand after upgrading.
  autocmd FileType vim setlocal keywordprg=:help
augroup END

augroup indentation
  autocmd!
  autocmd FileType json setlocal expandtab shiftwidth=2 softtabstop=-1
  autocmd FileType sh setlocal expandtab shiftwidth=4 softtabstop=-1
  autocmd FileType vim setlocal shiftwidth=2 softtabstop=-1
augroup END

augroup line_wrapping
  autocmd!
  autocmd FileType text setlocal linebreak wrap
augroup END

" The following escape-sequences allow CTRL-<arrow> to work as expected when
" Vim is run within tmux or GNU Screen.  CTRL-<arrow> is useful in insert mode
" and cmdline mode.
"
" NOTE:
"
"   1.  For these settings to work, tmux must be configured to have its
"       `xterm-keys' option set to on, so that tmux sends xterm-style function
"       key sequences on pressing CTRL-<arrow> (see `man tmux', under
"       `xterm-keys').  GNU Screen sends xterm-style function key sequences
"       for CTRL-<arrow> in its default configuration, at least in
"       versions >= 4.00.03 (FAU), so no additional configuration should be
"       necessary in GNU Screen.
"
"   2.  Check has('gui_running') to prevent assignment of these
"       escape-sequences in GUI-Vim when it is started from within tmux or
"       screen.  These sequences are unnecessary in GUI-Vim.  When GUI-Vim is
"       started from the shell, 'term' inherits its value from the environment
"       variable TERM (which in this case matches "tmux*" or "screen*"), and
"       does not change to 'builtin_gui' until some time after all the
"       commands in this file are executed.
if !has('gui_running') && &term =~# '^screen\|^tmux'
  " :execute is needed because we want \e to be parsed into literal ESC before
  " being assigned.
  execute "set <xUp>=\e[1;*A"
  execute "set <xDown>=\e[1;*B"
  execute "set <xRight>=\e[1;*C"
  execute "set <xLeft>=\e[1;*D"
endif

nnoremap <silent> <Leader>tu i<C-R>=strftime('%s')<CR><Esc>
nnoremap <silent> <Leader>ts i<C-R>=strftime('%Y-%m-%d %H:%M:%S %Z(UTC%z)')<CR><Esc>
nnoremap <silent> <Leader>] :echo synIDattr(synID(line('.'), col('.'), 1), 'name')<CR>

if executable('xsel')
  nnoremap <silent> <Leader>y :%write !xsel -ib 2>/dev/null<CR>
  xnoremap <silent> <Leader>y :write !xsel -ib 2>/dev/null<CR>
  nnoremap <silent> <Leader>p :read !xsel -ob 2>/dev/null<CR>
endif

nnoremap <Leader>e :silent edit<CR>
nnoremap <Leader>m :set invmodifiable<CR>
nnoremap <Leader>I :edit $MYVIMRC<CR>
nnoremap <Leader><Leader> :buffers<CR>:buffer<Space>
nnoremap <Leader>a :buffer #<CR>
nnoremap <Leader>z :bprevious<CR>
nnoremap <Leader>x :bnext<CR>
nnoremap <Leader>S :%substitute/\<<C-R><C-W>\>//g<Left><Left>
nnoremap <Leader>s :%substitute/\</g<Left><Left>
xnoremap <Leader>s :substitute/\</g<Left><Left>
nnoremap <Leader>g :%global/\<
xnoremap <Leader>g :global/\<
nnoremap <Leader>v :%vglobal/\<
xnoremap <Leader>v :vglobal/\<

" Do not highlight numbers, characters, and strings in comments in C / C++
" programs.
unlet! c_comment_strings

" The system-wide vimrc enables syntax conditionally: if GUI, or if the
" terminal supports more than 2 colors.  However, I want syntax to be enabled
" all the time, because without syntax, operators like `gq' etc. do not work
" correctly to format comments in programs.  I am, however, not keen on syntax
" _highlighting_, so I use my colorscheme which unhighlights most things.
syntax on
colorscheme raghuvrao

" Make vim more secure.  See `:h trojan-horse'.
set secure
set noexrc
