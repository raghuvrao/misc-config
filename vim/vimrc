scriptencoding utf-8

" ~/.vimrc ~/.vim/vimrc
" Author: Raghu V. Rao <raghu.v.rao@gmail.com>

set nobackup

set noundofile

set nomodeline
set modelines=0

let mapleader = '\'
let maplocalleader = '_'

set backspace=indent,eol,start

let &softtabstop=&tabstop

set ignorecase
set smartcase

set nowrap
nnoremap <Leader>w :set invwrap<CR>

set sidescroll=1

set nowildmenu
set wildmode=longest,list,full

" Set ruler even though I have line and column numbers in my statusline (see
" further below).  Infrequently and temporarily, I remove the statusline from
" view.  I want line- and column-number information to be displayed even in
" these situations.
set ruler

set showcmd

set foldmethod=indent
set foldlevel=100

set incsearch

nnoremap <Leader>h :nohlsearch<CR>

set list
set listchars=extends:#,precedes:#,nbsp:%
if has('multi_byte') && &encoding == 'utf-8'
  set listchars+=tab:→\ ,trail:¬
else
  set listchars+=tab:>\ ,trail:_
endif

set laststatus=2
set statusline=%(\ %f%)%(\ %q%)%(\ %M%R%H%W%)%(\ %y%)%(\ %l,%c%V\ %)

set report=0

" I do not want mouse support in Vim, whereas I like to have mouse support in
" GVim.  My system-wide vimrc enables mouse support in Vim, so disable it
" here.  Enable mouse support in GVim in the gvimrc file, which Vim does not
" read.
set mouse=

set nofixendofline

" Setting autoindent is typically unnecessary because filetype-specific
" indentation plugins take care of indentation sufficiently well.  However,
" with `n' included in formatoptions and with autoindent set, formatting
" numbered/bulleted lists (even in program comments) with the `gq' operator
" becomes so much easier.  Also, setting autoindent does not appear to be
" interfering with indentation done by filetype-specific indentation plugins.
" So, enable autoindent.
set autoindent

set textwidth=78

set history=500

" ftplugins shall add to / remove from the following formatoptions.
set formatoptions=1jlmnq

filetype plugin indent on

runtime ftplugin/man.vim

function! ToPositionWhenLastExitingCurrentBuffer()
  " If something has already moved the cursor, do not move it again.
  if getcurpos()[1:2] != [1, 1]
    return
  endif
  " If the line number where the cursor should be moved is either invalid or
  " no longer exists in the file, do not move the cursor.
  let l:target_line_number = line("'\"")
  if l:target_line_number < 1 || l:target_line_number > line('$')
    return
  endif
  " Do not move the cursor for some special buffers and for some filetypes.
  if expand('%:p') ==# ''
	\ || &diff
	\ || &buftype !=# ''
	\ || &filetype ==# 'git'
	\ || &filetype ==# 'gitcommit'
	\ || &filetype ==# 'gitrebase'
	\ || &filetype ==# 'hgcommit'
	\ || &filetype ==# 'man'
	\ || &filetype ==# 'svn'
    return
  endif
  " If we have come so far, it should be fine to move the cursor.
  normal! g`"zz
endfunction
augroup toPositionWhenLastExitingCurrentBuffer
  autocmd!
  autocmd BufReadPost * call ToPositionWhenLastExitingCurrentBuffer()
augroup END

" The following functions and autocommands work for :buffer #.  However, upon
" doing :edit # or CTRL-^, the current line still gets centered in the window.
" I do not (yet) know how to work around the undesired-automatic-scrolling
" problem after CTRL-^ / :edit #.  Not a huge problem because I use :b # far
" more than :edit # or CTRL-^.
function! SaveView()
  if &diff
    return
  endif
  if !exists('w:savedViews')
    let w:savedViews = {}
  endif
  let w:savedViews[bufnr('%')] = winsaveview()
endfunction
function! RestoreView()
  if &diff
    return
  endif
  if !exists('w:savedViews')
    return
  endif
  let l:thisBufNum = bufnr('%')
  if !has_key(w:savedViews, l:thisBufNum)
    return
  endif
  if getcurpos()[1:2] != [1, 1]
    call winrestview(w:savedViews[l:thisBufNum])
  endif
  unlet w:savedViews[l:thisBufNum]
endfunction
augroup no_disorientation
  autocmd!
  autocmd BufLeave * call SaveView()
  autocmd BufEnter * call RestoreView()
augroup END

" Make a few things work within tmux that work outside tmux.
"
" When GVim is started from the shell, 'term' inherits its value from the
" environment variable TERM first (which in this case matches "tmux*" or
" "screen*"), and changes to 'builtin_gui' at some point after this file is
" sourced.  So, check 'gui_running' here to avoid making the following
" assignments in GVim, where the assignments are unnecessary.
if !has('gui_running') && &term =~# '^screen\|^tmux'
  " xUp, xDown, xLeft and xRight can be used to make CTRL-<arrow> work as
  " expected when Vim is run within tmux or GNU Screen.  CTRL-<arrow> is
  " useful in the insert and command-line modes.
  "
  " For the terminal-sequences below to be effective in Vim running in tmux,
  " tmux must have its `xterm-keys' option set to on, so that tmux sends
  " xterm-style function key sequences on pressing CTRL-<arrow> (see `man
  " tmux', under `xterm-keys').
  "
  " GNU Screen sends xterm-style function key sequences for CTRL-<arrow> in
  " its default configuration, at least in versions >= 4.00.03 (FAU), so no
  " additional configuration should be necessary in GNU Screen.
  "
  " :execute is needed because we want \e to be parsed into literal ESC before
  " being assigned.
  execute "set <xUp>=\e[1;*A"
  execute "set <xDown>=\e[1;*B"
  execute "set <xRight>=\e[1;*C"
  execute "set <xLeft>=\e[1;*D"

  " Allow bracketed paste to work when Vim is running in tmux or GNU Screen.
  "
  " Bracketed paste support was added to GNU Screen in the following commit
  " (2015-06-25 17:05:31 +0200):
  "
  " https://git.savannah.gnu.org/cgit/screen.git/commit/?id=c389013e89e7b04ce43872f2e72d43f77461a3c0
  " ( https://lists.gnu.org/archive/html/screen-devel/2013-03/msg00000.html )
  "
  " A few relevant fixes were made in the following commit, several years
  " later (2019-02-14 20:30:23 +0100):
  "
  " https://git.savannah.gnu.org/cgit/screen.git/commit/?id=d2d33f664132e9473c62f37a4758a047fa83eb7a
  "
  " So, the minimum version of GNU Screen that is required for the sequences
  " below to be effective is the version at the first commit above.  It is
  " better to use a version at or after the second commit above.
  "
  " Support for bracketed paste was added in Vim 8.0.0210, whereas in some
  " computers I use, only older versions of Vim are available.
  if exists('+t_BD') && exists('+t_BE') && exists('+t_PS') && exists('+t_PE')
    let &t_BD = "\e[?2004l"
    let &t_BE = "\e[?2004h"
    let &t_PS = "\e[200~"
    let &t_PE = "\e[201~"
  endif
endif

nnoremap <silent> <Leader>tu i<C-R>=strftime('%s')<CR><Esc>
nnoremap <silent> <Leader>ts i<C-R>=strftime('%Y-%m-%d %H:%M:%S %Z(UTC%z)')<CR><Esc>
nnoremap <silent> <Leader>] :echo synIDattr(synID(line('.'), col('.'), 1), 'name')<CR>

if executable('xsel')
  nnoremap <silent> <Leader>y :%write !xsel -ib 2>/dev/null<CR>
  xnoremap <silent> <Leader>y :write !xsel -ib 2>/dev/null<CR>
  nnoremap <silent> <Leader>p :read !xsel -ob 2>/dev/null<CR>
endif

nnoremap <Leader>e :silent edit<CR>

nnoremap <Leader>m :set invmodifiable<CR>

nnoremap <Leader>I :edit $MYVIMRC<CR>

nnoremap <Leader>[ :ToggleMatchParen<CR>

nnoremap <Leader><Leader> :buffer<Space>
nnoremap <Leader>a :buffer #<CR>
nnoremap <Leader>z :bprevious<CR>
nnoremap <Leader>x :bnext<CR>

nnoremap <Leader>S :%substitute/\<<C-R><C-W>\>//g<Left><Left>
nnoremap <Leader>s :%substitute/\</g<Left><Left>
xnoremap <Leader>s :substitute/\</g<Left><Left>

nnoremap <Leader>g :%global/\<
xnoremap <Leader>g :global/\<
nnoremap <Leader>v :%vglobal/\<
xnoremap <Leader>v :vglobal/\<

" Do not highlight numbers, characters, and strings in comments in C / C++
" programs.
unlet! c_comment_strings

" The system-wide vimrc enables syntax conditionally: if GUI, or if the
" terminal supports more than 2 colors.  However, I want syntax to be enabled
" all the time, because without syntax, operators like `gq' etc. do not work
" correctly to format comments in programs.  I am, however, not keen on syntax
" _highlighting_, so I use my colorscheme which unhighlights most things.
syntax on
colorscheme raghuvrao

packadd! matchit

" Make vim more secure.  See `:h trojan-horse'.
set secure
set noexrc
