scriptencoding utf-8

" ~/.vimrc ~/.vim/vimrc
" Author: Raghu V. Rao <raghu.v.rao@gmail.com>

set nobackup

set noundofile

set nomodeline
set modelines=0

let mapleader = '\'
let maplocalleader = '_'

set backspace=indent,eol,start

let &softtabstop=&tabstop

set ignorecase
set smartcase

set nowrap
nnoremap <Leader>w :set invwrap<CR>

set sidescroll=1

" Do not allow the cursor to move onto the extends/precedes listchars when
" 'wrap' is disabled (which it is for me most of the time).  It becomes easier
" to understand the % motion on a long unwrapped line with several brackets in
" it.  The disadvantage is I must live with g$ and g^ moving the view by
" a column, which is OK for me because I do not use g$ and g^ a lot.
set sidescrolloff=1

set nowildmenu
set wildmode=longest,list,full

" Set ruler even though I have line and column numbers in my statusline (see
" further below).  Infrequently and temporarily, I remove the statusline from
" view.  I want line- and column-number information to be displayed even in
" these situations.
set ruler

set showcmd

set foldmethod=indent
set foldlevel=100

set incsearch

nnoremap <Leader>h :nohlsearch<CR>

set list
set listchars=extends:#,precedes:#,nbsp:%
if has('multi_byte') && &encoding == 'utf-8'
  set listchars+=tab:→\ ,trail:¬
else
  set listchars+=tab:>\ ,trail:_
endif

set laststatus=2
set statusline=%(\ %f%)%(\ %q%)%(\ %M%R%H%W%)%(\ %y%)%(\ %l,%c%V\ %)

set report=0

" I do not want mouse support in Vim, whereas I like to have mouse support in
" GVim.  My system-wide vimrc enables mouse support in Vim, so disable it
" here.  Enable mouse support in GVim in the gvimrc file, which Vim does not
" read.
set mouse=

set nofixendofline

" Setting autoindent is typically unnecessary because filetype-specific
" indentation plugins take care of indentation sufficiently well.  However,
" with `n' included in formatoptions and with autoindent set, formatting
" numbered/bulleted lists (even in program comments) with the `gq' operator
" becomes so much easier.  Also, setting autoindent does not appear to be
" interfering with indentation done by filetype-specific indentation plugins.
" So, enable autoindent.
set autoindent

set textwidth=78

set history=500

" ftplugins shall add to / remove from the following formatoptions.
set formatoptions=1jlmnq

filetype plugin indent on

runtime ftplugin/man.vim

function! JumpToLastExitPosition()
  " If something has already moved the cursor, do not move it again.
  if getcurpos()[1:2] != [1, 1]
    return
  endif
  " If the line number where the cursor should be moved is either invalid or
  " no longer exists in the file, do not move the cursor.
  let l:targetLineNumber = line("'\"")
  if l:targetLineNumber < 1 || l:targetLineNumber > line('$')
    return
  endif
  " Do not move the cursor for some special buffers and for some filetypes.
  if expand('%:p') ==# ''
	\ || &diff
	\ || &buftype !=# ''
	\ || &filetype ==# 'git'
	\ || &filetype ==# 'gitcommit'
	\ || &filetype ==# 'gitrebase'
	\ || &filetype ==# 'hgcommit'
	\ || &filetype ==# 'man'
	\ || &filetype ==# 'svn'
    return
  endif
  " If we have come so far, it should be fine to move the cursor.
  normal! g`"zz
endfunction
augroup jump_to_last_exit_position
  autocmd!
  autocmd BufReadPost * call JumpToLastExitPosition()
augroup END

" When switching from buffer B to buffer A in a window, and in buffer A, if
" the line containing the cursor was not at the center of the window, Vim
" scrolls buffer A such that the line containing the cursor is at the center
" of the window displaying that buffer.  I find this automatic scrolling
" disorienting and annoying. The following functions SaveView and RestoreView,
" and the corresponding autocommand group no_disorientation aim to address
" this problem.
"
" The following functions and autocommands work for :buffer #.  However, upon
" doing :edit # or CTRL-^, the current line still gets centered in the window.
" I do not (yet) know how to work around the undesired-automatic-scrolling
" problem after CTRL-^ / :edit #.  Not a huge problem because I use :b # far
" more than :edit # or CTRL-^.

function! SaveView()
  if &diff
    return
  endif
  if !exists('w:savedViews')
    let w:savedViews = {}
  endif
  let w:savedViews[bufnr('%')] = winsaveview()
endfunction

function! RestoreView()
  " Rationale for the getpos() call below (in other words, why we do nothing
  " in this function if the cursor is not at the start of the buffer):
  "
  "   When switching buffers within one window, Vim first sets the cursor
  "   position to the start of the file, then fires a BufEnter event;
  "   afterward, if no autocmd has changed the cursor position, Vim restores
  "   the cursor position based on values saved in its internal data
  "   structures.  In contrast, when switching to another window the cursor
  "   position is not forced to the start of the file; this includes the case
  "   when the user scrolls and clicks with the mouse.
  "
  " Source: <https://vim.fandom.com/wiki/Avoid_scrolling_when_switch_buffers>
  "
  " Because of the behaviour described above, restoring the view without
  " ensuring that the cursor was not already moved causes undesired scrolling:
  "
  " 1.  Remove getpos('.')[1:2] != [1, 1] || below, save this file, and close
  "     the editor.
  " 2.  Start GVim with the modified vimrc (I was unable to reproduce this
  "     problem in Vim).  Place the cursor on a line that is not the center
  "     line on the screen.  E.g., place the cursor on the top line or the
  "     bottom line on the screen.
  " 3.  Split the window, move the cursor/focus to the new window, and open
  "     another file in the new window.
  " 4.  With the cursor in this new window, scroll the original window using
  "     the mouse wheel.
  " 5.  Click on the status bar of the original window to move focus to the
  "     original window.
  "
  " The expected behaviour is that the buffer in the original window does not
  " scroll automatically.  The actual behaviour is that the buffer scrolls to
  " restore the saved view of the buffer before splitting the original window.
  " In order for actual behaviour to match expected behaviour, restore the
  " view only if the cursor is in the start of the buffer.
  if getpos('.')[1:2] != [1, 1] || !exists('w:savedViews') || &diff
    return
  endif
  let l:thisBufNum = bufnr('%')
  if !has_key(w:savedViews, l:thisBufNum)
    return
  endif
  call winrestview(w:savedViews[l:thisBufNum])
  unlet w:savedViews[l:thisBufNum]
endfunction

augroup no_disorientation
  autocmd!
  autocmd BufLeave * call SaveView()
  autocmd BufEnter * call RestoreView()
augroup END

function! MaximizeToTab()
  if winnr('$') == 1
    echo 'Cannot maximize: window already maximized'
    return
  endif
  let l:destTabNum = -1
  let l:curBufNum = bufnr('%')
  " Find the tab page where the current buffer is the only one displayed.  If
  " it exists, we will simply switch to that tab page instead of creating
  " a new one.
  for l:i in range(tabpagenr('$'))
    " range() starts from 0, tab pages are numbered starting from 1.
    let l:tabNum = l:i + 1
    if tabpagewinnr(l:tabNum, '$') == 1 && tabpagebuflist(l:tabNum)[0] == l:curBufNum
      let l:destTabNum = l:tabNum
      break
    endif
  endfor
  let l:winID = win_getid()
  let l:lineNum = line('.')
  let l:colNum = col('.')
  if l:destTabNum > -1
    execute 'tabnext ' . l:destTabNum
    call cursor(l:lineNum, l:colNum)
  else
    tab split
  endif
  let w:maximizedFromWinID = l:winID
  echo ''
endfunction
nnoremap <silent> <Leader><CR> :call MaximizeToTab()<CR>

function! UnmaximizeFromTab() abort
  let l:numWindowsInTab = winnr('$')
  if l:numWindowsInTab > 1
    echo 'Cannot unmaximize: window not maximized'
    return
  endif
  if tabpagenr('$') == 1 && l:numWindowsInTab == 1
    echo 'Cannot unmaximize: only window in only tab'
    return
  endif
  if !exists('w:maximizedFromWinID') || type(w:maximizedFromWinID) != type(win_getid())
    echo 'Cannot unmaximize: origin window unknown'
    return
  endif
  let l:bufNrInOriginWin = winbufnr(w:maximizedFromWinID)
  if l:bufNrInOriginWin == -1
    echo 'Cannot unmaximize: origin window does not exist'
    return
  endif
  if l:bufNrInOriginWin != bufnr('%')
    echo 'Cannot unmaximize: different buffer displayed in origin window'
    return
  endif
  let l:maxdTab = tabpagenr()
  let l:lineNum = line('.')
  let l:colNum = col('.')
  if win_gotoid(w:maximizedFromWinID)
    call cursor(l:lineNum, l:colNum)
    execute 'tabclose ' . l:maxdTab
    echo ''
  else
    " Probably no way to reach here.  The check above for winbufnr() returning
    " -1 will catch the case where the origin window does not exist.
    echo 'Cannot unmaximize: origin window not found'
    return
  endif
endfunction
nnoremap <silent> <Leader><BS> :call UnmaximizeFromTab()<CR>

" Make a few things work within tmux that work outside tmux.
"
" When GVim is started from the shell, 'term' inherits its value from the
" environment variable TERM first (which in this case matches "tmux*" or
" "screen*"), and changes to 'builtin_gui' at some point after this file is
" sourced.  So, check 'gui_running' here to avoid making the following
" assignments in GVim, where the assignments are unnecessary.
if !has('gui_running') && &term =~# '^screen\|^tmux'
  " xUp, xDown, xLeft and xRight can be used to make CTRL-<arrow> work as
  " expected when Vim is run within tmux or GNU Screen.  CTRL-<arrow> is
  " useful in the insert and command-line modes.
  "
  " For the terminal-sequences below to be effective in Vim running in tmux,
  " tmux must have its `xterm-keys' option set to on, so that tmux sends
  " xterm-style function key sequences on pressing CTRL-<arrow> (see `man
  " tmux', under `xterm-keys').
  "
  " GNU Screen sends xterm-style function key sequences for CTRL-<arrow> in
  " its default configuration, at least in versions >= 4.00.03 (FAU), so no
  " additional configuration should be necessary in GNU Screen.
  "
  " :execute is needed because we want \e to be parsed into literal ESC before
  " being assigned.
  execute "set <xUp>=\e[1;*A"
  execute "set <xDown>=\e[1;*B"
  execute "set <xRight>=\e[1;*C"
  execute "set <xLeft>=\e[1;*D"

  " Allow bracketed paste to work when Vim is running in tmux or GNU Screen.
  "
  " Bracketed paste support was added to GNU Screen in the following commit
  " (2015-06-25 17:05:31 +0200):
  "
  " https://git.savannah.gnu.org/cgit/screen.git/commit/?id=c389013e89e7b04ce43872f2e72d43f77461a3c0
  " ( https://lists.gnu.org/archive/html/screen-devel/2013-03/msg00000.html )
  "
  " A few relevant fixes were made in the following commit, several years
  " later (2019-02-14 20:30:23 +0100):
  "
  " https://git.savannah.gnu.org/cgit/screen.git/commit/?id=d2d33f664132e9473c62f37a4758a047fa83eb7a
  "
  " So, the minimum version of GNU Screen that is required for the sequences
  " below to be effective is the version at the first commit above.  It is
  " better to use a version at or after the second commit above.
  "
  " Support for bracketed paste was added in Vim 8.0.0210, whereas in some
  " computers I use, only older versions of Vim are available.
  if exists('+t_BD') && exists('+t_BE')
    let &t_BD = "\<Esc>[?2004l"
    let &t_BE = "\<Esc>[?2004h"
    " t_PS and t_PE do not exist initially (which is why we do not check for
    " them in the if-condition above).  Define them now (see :h :let-&).
    let &t_PS = "\<Esc>[200~"
    let &t_PE = "\<Esc>[201~"
  endif
endif

nnoremap <silent> <Leader>tu i<C-R>=strftime('%s')<CR><Esc>
nnoremap <silent> <Leader>ts i<C-R>=strftime('%Y-%m-%d %H:%M:%S %Z(UTC%z)')<CR><Esc>
nnoremap <silent> <Leader>] :echo synIDattr(synID(line('.'), col('.'), 1), 'name')<CR>

if executable('xsel')
  nnoremap <silent> <Leader>y :%write !xsel -ib 2>/dev/null<CR>
  xnoremap <silent> <Leader>y :write !xsel -ib 2>/dev/null<CR>
  nnoremap <silent> <Leader>p :read !xsel -ob 2>/dev/null<CR>
endif

nnoremap <Leader>e :silent edit<CR>

nnoremap <Leader>m :set invmodifiable<CR>

nnoremap <Leader>I :edit $MYVIMRC<CR>

nnoremap <Leader>[ :ToggleMatchParen<CR>

nnoremap <Leader><Leader> :buffer<Space>
nnoremap <Leader>a :buffer #<CR>
nnoremap <Leader>z :bprevious<CR>
nnoremap <Leader>x :bnext<CR>

nnoremap <Leader>S :%substitute/\<<C-R><C-W>\>//g<Left><Left>
nnoremap <Leader>s :%substitute/\</g<Left><Left>
xnoremap <Leader>s :substitute/\</g<Left><Left>

nnoremap <Leader>g :%global/\<
xnoremap <Leader>g :global/\<
nnoremap <Leader>v :%vglobal/\<
xnoremap <Leader>v :vglobal/\<

" Do not highlight numbers, characters, and strings in comments in C / C++
" programs.
unlet! c_comment_strings

" The system-wide vimrc enables syntax conditionally: if GUI, or if the
" terminal supports more than 2 colors.  However, I want syntax to be enabled
" all the time, because without syntax, operators like `gq' etc. do not work
" correctly to format comments in programs.  I am, however, not keen on syntax
" _highlighting_, so I use my colorscheme which unhighlights most things.
syntax on
colorscheme raghuvrao

packadd! matchit

" Make vim more secure.  See `:h trojan-horse'.
set secure
set noexrc
